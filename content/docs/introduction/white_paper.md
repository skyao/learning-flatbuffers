---
title: "FlatBuffers白皮书"
linkTitle: "白皮书"
weight: 10
date: 2022-09-05
description: >
  FlatBuffers白皮书
---



> https://google.github.io/flatbuffers/flatbuffers_white_paper.html

本文试图阐明 FlatBuffers 这个新的序列化库的一些 "why"。

## 动机

在过去的好日子里，性能都是关于指令和周期的。如今，处理单元已经远远领先于内存子系统，因此，制作一个高效的应用程序应该始终考虑内存。你使用了多少内存。你如何布置它和访问它。你如何分配它。何时复制它。

序列化是很多程序中普遍存在的行为，也是内存效率低下的一个常见来源，需要大量的临时数据结构来解析和表示数据，以及低效的分配模式和位置。

如果能够在没有临时对象、没有额外分配、没有复制和良好定位的情况下进行序列化，这将是非常有价值的。序列化系统通常不管理这一点的原因是，它违背了前后兼容的原则，以及平台的特殊性，如字节数和对齐。

如果你尝试，你会得到 FlatBuffers。

特别是，FlatBuffers 的重点是移动硬件（那里的内存大小和内存带宽甚至比桌面硬件更受限制），以及对性能有最高需求的应用程序：游戏。

## FlatBuffers
这是对 FlatBuffers 功能的总结，并附有一些理由。更详细的描述可以在 FlatBuffers 文档中找到。

## 摘要

FlatBuffer 是一个包含嵌套对象（结构体、表格、向量......）的二进制缓冲区，使用偏移量(offset)来组织，这样数据就可以像任何基于指针的数据结构一样被就地遍历。然而，与大多数内存数据结构不同的是，它使用严格的对齐和字节数规则（总是小的）来确保这些缓冲区是跨平台的。此外，对于作为表格的对象，FlatBuffers提供了向前/向后的兼容性和字段的一般选择性，以支持大多数形式的格式演变。

你可以在一个模式中定义你的对象类型，然后将其编译为C++或Java，以实现低至零的读写开销。可选的是，JSON数据可以被动态解析为缓冲区。

## table

table 是 FlatBuffers 的基石，因为格式的演变对于大多数序列化的应用来说是必不可少的。一般来说，处理格式变化是可以在大多数序列化解决方案的解析过程中透明地完成的事情。但是 FlatBuffer 在被访问之前并没有被解析。

table 通过使用一个额外的中介来访问字段，通过 vtable 来解决这个问题。每个表都有一个vtable（它可能在具有相同布局的多个表之间共享），并包含这种 vtable 的特定实例的字段被存储的信息。vtable 也可能表明该字段不存在（因为这个 FlatBuffer 是用旧版本的软件编写的，或者仅仅是因为该信息对这个实例来说是不必要的，或者被认为是废弃的），在这种情况下，会返回一个默认值。

table 在内存中的开销很低（因为 vtables 很小，而且是共享的），在访问成本上也很低（一个额外的中介），但是提供了很大的灵活性。table 甚至可能比同等的结构体花费更少的内存，因为当字段等于其默认值时，不需要存储。

FlatBuffers 还提供了 "naked" 结构体，它不提供前向/后向兼容性，但可以更小（对于不太可能改变的非常小的对象来说非常有用，例如坐标对或 RGBA 颜色）。



## 模式



虽然模式减少了一些通用性（你不能在没有模式的情况下直接读取任何数据），但它们也有很多优点。

- 大多数关于格式的信息都可以考虑到生成的代码中，减少了存储数据所需的内存和访问数据的时间。

- 数据定义的强类型化意味着运行时的错误检查/处理更少（出错的可能性更小）。

- 模式使我们能够在不解析的情况下访问缓冲区。

FlatBuffer 的模式与现有的 Protocol Buffers 的模式相当相似，一般来说，熟悉C语言家族的人应该可以阅读。我们选择以下列方式改进·.proto· 文件所提供的功能。

- 废弃字段，而不是手动分配字段ID。在 `.proto` 中扩展一个对象意味着在数字中寻找一个空闲的槽（更喜欢低数字，因为它们有更紧凑的表示）。除了不方便之外，它还使删除字段成为问题：你要么保留它们，不明显地指出这个字段不应该再被读/写，并且仍然产生访问器。或者你删除它，但现在你要冒的风险是，当有人重新使用这个字段的时候，周围仍然有使用这个字段的旧数据，这就会造成糟糕的后果。
- 区分表和结构体（见上文）。实际上，所有的表字段都是可选的，而所有的结构体字段都是必须的。

- 拥有一个本地的向量类型，而不是重复的。这给了你一个长度，而不需要收集所有的项目，在标量的情况下，提供了一个更紧凑的表示，并且保证了邻接性。

- 有一个本地的联合类型，而不是使用一系列的可选字段，所有这些字段都必须被单独检查。

- 能够为所有标量定义默认值，而不是在每次访问时都要处理它们的可选性。

- 一个能够统一处理模式和数据定义（兼容JSON）的解析器。

